<<<<<<< HEAD
const path = require('path');
const fs = require('fs');
const existsSync = fs.existsSync;
const utils = require('../utils');

module.exports = exec;
module.exports.expandScript = expandScript;
=======
'use strict';
var path = require('path'),
    utils = require('../utils');

module.exports = exec;
module.exports.parseExecutable = parseExecutable;

function parseExecutable(str) {
  var length = str.length;
  var i = 0;

  var exec = null;
  var execArgs = [];
  var token = '';
  var inspace = false;
  var escaped = false;
  var unescapeNextTime = false;
  var open = false;
  var c = null;
  var isescape = false;

  for (; i < length; i++) {
    c = str[i];

    if (unescapeNextTime) {
      escaped = false;
    }

    unescapeNextTime = escaped;

    if (c === '\\' && !utils.isWindows) {
      isescape = true;
    } else if (c === '^' && utils.isWindows) {
      isescape = true;
    } else {
      isescape = false;
    }

    if (isescape) {
      escaped = true;
      // peek next character
      if (str[i+1] === ' ') { // space we skip
        inspace = true;
      }

      if (utils.isWindows) {
        continue; // chomp the carat
      }
    }

    if (!escaped && (c === '"' || c === "'")) {
      open = !open;
      // continue;
    }

    if (c === ' ') {
      if (!open && inspace === false) {
        if (exec === null) {
          exec = token;
          execArgs.push(str.slice(i + 1));
          token = '';
          break;
        } else {
          execArgs.push(token);
        }

        // reset the token now
        token = '';
        continue;
      } else if (inspace) {
        inspace = false;
      }
    }

    token += c;
  }

  // deal with the left overs
  if (exec === null) {
    exec = token;
  } else if (token) {
    execArgs.push(token);
  }

  var result = {
    exec: exec,
    execArgs: execArgs,
  };

  return result;
}
>>>>>>> 71875195c0f4e574414444283f39864d3fbbcb73

/**
 * Reads the cwd/package.json file and looks to see if it can load a script
 * and possibly an exec first from package.main, then package.start.
 *
 * @return {Object} exec & script if found
 */
function execFromPackage() {
  // doing a try/catch because we can't use the path.exist callback pattern
  // or we could, but the code would get messy, so this will do exactly
  // what we're after - if the file doesn't exist, it'll throw.
  try {
    // note: this isn't nodemon's package, it's the user's cwd package
    var pkg = require(path.join(process.cwd(), 'package.json'));
    if (pkg.main !== undefined) {
      // no app found to run - so give them a tip and get the feck out
      return { exec: null, script: pkg.main };
<<<<<<< HEAD
    }

    if (pkg.scripts && pkg.scripts.start) {
      return { exec: pkg.scripts.start };
    }
  } catch (e) { }
=======
    } else if (pkg.scripts && pkg.scripts.start) {
      var start = pkg.scripts.start.split(' ');
      return { exec: start[0], script: start.slice(1).join(' ') };
    }
  } catch (e) {}
>>>>>>> 71875195c0f4e574414444283f39864d3fbbcb73

  return null;
}

function replace(map, str) {
<<<<<<< HEAD
  var re = new RegExp('{{(' + Object.keys(map).join('|') + ')}}', 'g');
  return str.replace(re, function (all, m) {
=======
  return str.replace(new RegExp('\{\{(' + Object.keys(map).join('|') + ')\}\}'), function (all, m) {
>>>>>>> 71875195c0f4e574414444283f39864d3fbbcb73
    return map[m] || all || '';
  });
}

<<<<<<< HEAD
function expandScript(script, ext) {
  if (!ext) {
    ext = '.js';
  }
  if (script.indexOf(ext) !== -1) {
    return script;
  }

  if (existsSync(path.resolve(script))) {
    return script;
  }

  if (existsSync(path.resolve(script + ext))) {
    return script + ext;
  }

  return script;
}
=======
>>>>>>> 71875195c0f4e574414444283f39864d3fbbcb73

/**
 * Discovers all the options required to run the script
 * and if a custom exec has been passed in, then it will
 * also try to work out what extensions to monitor and
 * whether there's a special way of running that script.
 *
 * @param  {Object} nodemonOptions
 * @param  {Object} execMap
 * @return {Object} new and updated version of nodemonOptions
 */
function exec(nodemonOptions, execMap) {
  if (!execMap) {
    execMap = {};
  }

<<<<<<< HEAD
  var options = utils.clone(nodemonOptions || {});
  var script;

  // if there's no script passed, try to get it from the first argument
  if (!options.script && (options.args || []).length) {
    script = expandScript(options.args[0],
      options.ext && ('.' + (options.ext || 'js').split(',')[0]));

    // if the script was found, shift it off our args
    if (script !== options.args[0]) {
      options.script = script;
      options.args.shift();
    }
  }

  // if there's no exec found yet, then try to read it from the local
  // package.json this logic used to sit in the cli/parse, but actually the cli
  // should be parsed first, then the user options (via nodemon.json) then
  // finally default down to pot shots at the directory via package.json
  if (!options.exec && !options.script) {
    var found = execFromPackage();
    if (found !== null) {
      if (found.exec) {
        options.exec = found.exec;
      }
      if (!options.script) {
        options.script = found.script;
      }
      if (Array.isArray(options.args) &&
        options.scriptPosition === null) {
        options.scriptPosition = options.args.length;
=======
  // if there's no exec found yet, then try to read it from the local package.json
  // this logic used to sit in the cli/parse, but actually the cli should be parsed
  // first, then the user options (via nodemon.json) then finally default down to
  // pot shots at the directory via package.json
  if (!nodemonOptions.exec && !nodemonOptions.script) {
    var found = execFromPackage();
    if (found !== null) {
      if (found.exec) {
        nodemonOptions.exec = found.exec;
      }
      if (!nodemonOptions.script) {
        nodemonOptions.script = found.script;
      }
      if (Array.isArray(nodemonOptions.args) && nodemonOptions.scriptPosition === null) {
        nodemonOptions.scriptPosition = nodemonOptions.args.length;
>>>>>>> 71875195c0f4e574414444283f39864d3fbbcb73
      }
    }
  }

<<<<<<< HEAD
  // var options = utils.clone(nodemonOptions || {});
  script = path.basename(options.script || '');

  var scriptExt = path.extname(script).slice(1);

  var extension = options.ext;
  if (extension === undefined) {
    var isJS = scriptExt === 'js' || scriptExt === 'mjs';
    extension = (isJS || !scriptExt) ? 'js,mjs' : scriptExt;
    extension += ',json'; // Always watch JSON files
  }

  var execDefined = !!options.exec;

  // allows the user to simplify cli usage:
  // https://github.com/remy/nodemon/issues/195
=======
  var options = utils.clone(nodemonOptions || {}),
      script = path.basename(options.script || ''),
      scriptExt = path.extname(script).slice(1),
      extension = options.ext || scriptExt || 'js',
      execDefined = !!options.exec;

  // strip any leading periods int he extension
  if (extension.indexOf('.') === 0) {
    extension = extension.slice(1);
  }

  // allows the user to simplify cli usage: https://github.com/remy/nodemon/issues/195
>>>>>>> 71875195c0f4e574414444283f39864d3fbbcb73
  // but always give preference to the user defined argument
  if (!options.exec && execMap[scriptExt] !== undefined) {
    options.exec = execMap[scriptExt];
    execDefined = true;
  }

<<<<<<< HEAD
  options.execArgs = nodemonOptions.execArgs || [];
=======
  options.execArgs = [];
>>>>>>> 71875195c0f4e574414444283f39864d3fbbcb73

  if (Array.isArray(options.exec)) {
    options.execArgs = options.exec;
    options.exec = options.execArgs.shift();
<<<<<<< HEAD
=======
  } else if (options.exec && options.exec.indexOf(' ') !== -1) {
    options = utils.merge(parseExecutable(options.exec), options);
>>>>>>> 71875195c0f4e574414444283f39864d3fbbcb73
  }

  if (options.exec === undefined) {
    options.exec = 'node';
  } else {
    // allow variable substitution for {{filename}} and {{pwd}}
<<<<<<< HEAD
    var substitution = replace.bind(null, {
      filename: options.script,
      pwd: process.cwd(),
    });

    var newExec = substitution(options.exec);
    if (newExec !== options.exec &&
      options.exec.indexOf('{{filename}}') !== -1) {
      options.script = null;
    }
    options.exec = newExec;
=======
    var substitution = replace.bind(null, { filename: script, pwd: process.cwd() });
    options.exec = substitution(options.exec);
>>>>>>> 71875195c0f4e574414444283f39864d3fbbcb73

    var newExecArgs = options.execArgs.map(substitution);
    if (newExecArgs.join('') !== options.execArgs.join('')) {
      options.execArgs = newExecArgs;
      delete options.script;
    }
  }


  if (options.exec === 'node' && options.nodeArgs && options.nodeArgs.length) {
    options.execArgs = options.execArgs.concat(options.nodeArgs);
  }

  // note: indexOf('coffee') handles both .coffee and .litcoffee
<<<<<<< HEAD
  if (!execDefined && options.exec === 'node' &&
    scriptExt.indexOf('coffee') !== -1) {
    options.exec = 'coffee';

    // we need to get execArgs set before the script
    // for example, in `nodemon --debug my-script.coffee --my-flag`, debug is an
    // execArg, while my-flag is a script arg
    var leadingArgs = (options.args || []).splice(0, options.scriptPosition);
    options.execArgs = options.execArgs.concat(leadingArgs);
    options.scriptPosition = 0;

    if (options.execArgs.length > 0) {
      // because this is the coffee executable, we need to combine the exec args
      // into a single argument after the nodejs flag
      options.execArgs = ['--nodejs', options.execArgs.join(' ')];
=======
  if (!execDefined && options.exec === 'node' && scriptExt.indexOf('coffee') !== -1) {
    options.exec = 'coffee';
    // ensure that we call: `coffee --nodejs ...`
    if (options.execArgs === undefined) {
      options.execArgs = [];
    }
    // if there's a leading argument to the exec that starts with `--` then
    // it could be --debug or --debug-brk or something else intended for node
    // so we'll add the --nodejs switch.
    if ((options.args || []).join(' ').indexOf('--') === 0) {
      options.execArgs.unshift('--nodejs');
>>>>>>> 71875195c0f4e574414444283f39864d3fbbcb73
    }
  }

  if (options.exec === 'coffee') {
    // don't override user specified extension tracking
<<<<<<< HEAD
    if (options.ext === undefined) {
      if (extension) { extension += ','; }
      extension += 'coffee,litcoffee';
=======
    if (!options.ext) {
      extension = 'coffee litcoffee js';
>>>>>>> 71875195c0f4e574414444283f39864d3fbbcb73
    }

    // because windows can't find 'coffee', it needs the real file 'coffee.cmd'
    if (utils.isWindows) {
      options.exec += '.cmd';
    }
  }

  // allow users to make a mistake on the extension to monitor
<<<<<<< HEAD
  // converts .js, pug => js,pug
  // BIG NOTE: user can't do this: nodemon -e *.js
  // because the terminal will automatically expand the glob against
  // the file system :(
  extension = (extension.match(/[^,*\s]+/g) || [])
    .map(ext => ext.replace(/^\./, ''))
    .join(',');

  options.ext = extension;

  if (options.script) {
    options.script = expandScript(options.script,
      extension && ('.' + extension.split(',')[0]));
  }

=======
  // converts js,jade => js,jade
  // and 'js jade' => js,jade
  // BIG NOTE: user can't do this: nodemon -e *.js
  // because the terminal will automatically expand the glob against
  // the file system :(
  if (extension.indexOf(' ') !== -1 ||
      extension.indexOf(',') !== -1 ||
      extension.indexOf('*.') !== -1) {

    extension = extension.replace(/\s+/g, '|') // convert spaces to pipes
      .replace(/,/g, '|') // convert commas to pipes
      .split('|') // split on those pipes
      .map(function (item) {
        return item.replace(/^[\*\.]+/, ''); // remove "*."
      }).join(','); // return regexp string like: js,jade
  }

  options.ext = extension;

>>>>>>> 71875195c0f4e574414444283f39864d3fbbcb73
  options.env = {};
  // make sure it's an object (and since we don't have )
  if (({}).toString.apply(nodemonOptions.env) === '[object Object]') {
    options.env = utils.clone(nodemonOptions.env);
  } else if (nodemonOptions.env !== undefined) {
    throw new Error('nodemon env values must be an object: { PORT: 8000 }');
  }

  return options;
<<<<<<< HEAD
}
=======
}
>>>>>>> 71875195c0f4e574414444283f39864d3fbbcb73
